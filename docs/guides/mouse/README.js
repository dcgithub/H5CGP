Ext.data.JsonP.mouse({"guide":"<h1 id='mouse-section-h5cgb-mouse-interaction-tutorial---build-an-rts-game'>H5CGB Mouse Interaction Tutorial - Build an RTS game</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/mouse-section-prerequisites'>Prerequisites</a></li>\n<li><a href='#!/guide/mouse-section-mouse-scrolling-and-zooming'>Mouse Scrolling and Zooming</a></li>\n<li><a href='#!/guide/mouse-section-hovering'>Hovering</a></li>\n<li><a href='#!/guide/mouse-section-mouse-clicking-and-coordinates'>Mouse Clicking and Coordinates</a></li>\n<li><a href='#!/guide/mouse-section-mouse-dragging'>Mouse Dragging</a></li>\n<li><a href='#!/guide/mouse-section-exercises-for-the-reader'>Exercises for the Reader</a></li>\n<li><a href='#!/guide/mouse-section-recap'>Recap</a></li>\n</ol>\n</div>\n\n<p>This guide introduces the mouse interaction tools for JavaScript canvas\napplications provided by\n<a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate\">HTML5 Canvas Game Boilerplate</a>\nby using them to write a\n<a href=\"https://en.wikipedia.org/wiki/Command_and_conquer\">C&amp;C</a>-style RTS game.</p>\n\n<p><img src=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/raw/gh-pages/guides/mouse/screen02.png\" alt=\"Finished game\" /></p>\n\n<h2 id='mouse-section-prerequisites'>Prerequisites</h2>\n\n<p>You should already be familiar with the concepts introduced in the\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/guide/walkthrough\">basics walkthrough</a>.\nTo avoid rehashing those lessons, we're going to start with most of the game\nbuilt out already; in fact, we'll skip everything that could be built with the\ntools introduced in that tutorial. Since that's too much code to copy-paste\nhere, you can\n<a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/blob/gh-pages/guides/mouse/rts00-prereqs.js\">read through it</a>\nseparately.</p>\n\n<p>Specifically, here's what we'll assume we're starting with:</p>\n\n<ul>\n<li>A large world with a background layer</li>\n<li>Multiple teams, each with a base in the world that generates soldiers</li>\n<li>Soldiers have the ability to move if properly instructed</li>\n<li>Soldiers can shoot at enemy soldiers, and lose health if hit</li>\n<li>Soldiers have a health bar, and bases have a progress bar for spawning\nsoldiers</li>\n<li>Soldiers can collide with each other</li>\n</ul>\n\n\n<p>And here's what all that looks like:</p>\n\n<p><img src=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/raw/gh-pages/guides/mouse/screen00.png\" alt=\"Starting point\" /></p>\n\n<p>As a reminder, all the code we'll be writing in this tutorial goes in <code>main.js</code>.</p>\n\n<h2 id='mouse-section-mouse-scrolling-and-zooming'>Mouse Scrolling and Zooming</h2>\n\n<p>The world we've created is bigger than what we can fit in view, so we need a\nway to navigate around it. In the basics walkthrough we saw that the viewport\nwill automatically scroll around a Player object, but we don't have a Player\nhere. Instead, we'll scroll the viewport when the mouse gets near an edge.\nDoing this is just one line of code that we have to place at the end of\n<code>setup()</code>:</p>\n\n<pre><code><a href=\"#!/api/Mouse.Scroll-static-method-enable\" rel=\"Mouse.Scroll-static-method-enable\" class=\"docClass\">Mouse.Scroll.enable</a>();\n</code></pre>\n\n<p>There are three factors that affect how mouse scrolling behaves. The first is\nthe \"scroll threshold,\" which is how close to an edge the mouse needs to be in\norder to trigger scrolling. The second is the \"scroll distance,\" which is how\nfar the viewport should scroll. The third is the \"easing function,\" which\ndefines how fast scrolling reaches maximum speed. Here's how to set them:</p>\n\n<pre><code><a href=\"#!/api/Mouse.Scroll-static-method-setThreshold\" rel=\"Mouse.Scroll-static-method-setThreshold\" class=\"docClass\">Mouse.Scroll.setThreshold</a>(0.3);\n<a href=\"#!/api/Mouse.Scroll-static-method-setScrollDistance\" rel=\"Mouse.Scroll-static-method-setScrollDistance\" class=\"docClass\">Mouse.Scroll.setScrollDistance</a>(800);\n<a href=\"#!/api/Mouse.Scroll-static-method-setEasingFunction\" rel=\"Mouse.Scroll-static-method-setEasingFunction\" class=\"docClass\">Mouse.Scroll.setEasingFunction</a>(Mouse.Scroll.easings.SMOOTH);\n</code></pre>\n\n<p>You can read more in the\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/Mouse.Scroll\">Mouse.Scroll</a>\ndocumentation.</p>\n\n<p>Sometimes when your world is really big, scrolling doesn't let you move around\nquickly enough or see everything you want in view. This isn't an especially\ncommon requirement, so it's not included in <code>combined.js</code>, but you can add\nsupport for this functionality by including <code>zoom.js</code> in your <code>index.html</code>:</p>\n\n<pre><code>&lt;script src=\"js/boilerplate/zoom.js\"&gt;&lt;/script&gt;\n</code></pre>\n\n<p>Once you've done that, you can allow the player to zoom in and out like this:</p>\n\n<pre><code><a href=\"#!/api/Mouse.Zoom-static-method-enable\" rel=\"Mouse.Zoom-static-method-enable\" class=\"docClass\">Mouse.Zoom.enable</a>(true);\n</code></pre>\n\n<p>(We'll also put this at the end of <code>setup()</code>.) The <code>true</code> parameter indicates\nthat we want to display an indicator of our zoom level so we know how far in or\nout we've zoomed. You can configure what that indicator looks like, but here's\nthe default:</p>\n\n<p><img src=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/raw/gh-pages/guides/mouse/screen01.png\" alt=\"Zooming\" /></p>\n\n<p>You can also configure how fast and how far in and out you can zoom by changing\nvalues on the\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/Mouse.Zoom\">Mouse.Zoom</a>\nobject.</p>\n\n<p><em><a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/blob/gh-pages/guides/mouse/rts01-scrollzoom.js\">Review the code for this section</a></em></p>\n\n<h2 id='mouse-section-hovering'>Hovering</h2>\n\n<p>Any instance of <code>Box</code> or any of its descendants have an\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/Box-method-isHovered\"><code>isHovered()</code></a>\nmethod that returns <code>true</code> or <code>false</code> depending on whether the mouse is\ncurrently hovered over it, respectively. For non-Box objects there is the\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/App-static-method-isHovered\"><code>App.isHovered()</code></a>\nfunction which accepts anything with <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> properties.</p>\n\n<p>In our case, it would be nice to have soldiers change color when hovering over\nthem in order to make it clear when they can be selected. In\n<code>Soldier#drawDefault()</code>, change this:</p>\n\n<pre><code>this.fillStyle = this.selected ? this.team.soldierSelectedColor :\n  this.team.soldierColor;\n</code></pre>\n\n<p>to this:</p>\n\n<pre><code>this.fillStyle = this.selected ? this.team.soldierSelectedColor :\n  (this.isHovered() ? this.team.soldierHoverColor : this.team.soldierColor);\n</code></pre>\n\n<p><em><a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/blob/gh-pages/guides/mouse/rts02-hover.js\">Review the code for this section</a></em></p>\n\n<h2 id='mouse-section-mouse-clicking-and-coordinates'>Mouse Clicking and Coordinates</h2>\n\n<p>At this point we have lots of behavior defined for soldiers, but we don't have\na way to instruct them to move. Let's do this by selecting soldiers by clicking\non them and then telling them where to go by right-clicking on the map.</p>\n\n<p>First, at the end of <code>Soldier#init()</code>, we'll need to tell the soldiers to be\nselected when we click on them:</p>\n\n<pre><code>if (team != myTeam) return; // Only allow selecting the player's team\nvar t = this;\n// Allow selecting soldiers by clicking on them\nthis.listen('mousedown.select touchstart.select', function(e) {\n  // Left click or touch only\n  if (typeof e !== 'undefined' &amp;&amp; e.type == 'mousedown' &amp;&amp; e.which !== 1) {\n    return;\n  }\n  // Holding down CTRL allows selecting multiple soldiers.\n  if (!<a href=\"#!/api/jQuery.hotkeys-method-areKeysDown\" rel=\"jQuery.hotkeys-method-areKeysDown\" class=\"docClass\">jQuery.hotkeys.areKeysDown</a>('ctrl')) {\n    t.team.soldiers.forEach(function(soldier) {\n      soldier.selected = false;\n    });\n  }\n  t.toggleSelected.call(t);\n  // Don't bubble the event\n  e.stopPropagation();\n});\n</code></pre>\n\n<p>And in <code>Soldier#destroy()</code>:</p>\n\n<pre><code>this.unlisten('.select');\n</code></pre>\n\n<p>We added a listener to the soldier object that listens for the \"mousedown\" or\n\"touchstart\" events (i.e. clicks) and toggles the <code>selected</code> property\nappropriately. This is a utility provided by H5CGB; there is no native way to\ninteract with objects drawn onto canvases because unlike DOM elements, the\ncanvas is viewed as an entire image without sub-components. To get around this,\nH5CGB provides a jQuery-style\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/App.Events\">event system</a>\nfor canvas objects.</p>\n\n<p>Note the call to <code>e.stopPropagation()</code>. This prevents the event from bubbling\nso that it's not called on other objects occupying the same space. In this\ncase, this is important because we'll also want the background to listen to\nclick events for our right-click-to-move behavior. While we're at it, let's\nalso unselect all soldiers if we left-click on the background. At the end of\n<code>setup()</code>:</p>\n\n<pre><code>// Respond to clicks on the background\n<a href=\"#!/api/App.Events-static-method-listen\" rel=\"App.Events-static-method-listen\" class=\"docClass\">App.Events.listen</a>(bkgd, 'mousedown.bkgd, touchstart.bkgd', function(e) {\n  // Right click -&gt; Move\n  if (e.type == 'mousedown' &amp;&amp; e.which === 3) {\n    moveSelectedSoldiersToMouse();\n  }\n  // Touch or left click -&gt; Deselect all\n  else {\n    // Holding down CTRL allows selecting multiple soldiers.\n    if (!<a href=\"#!/api/jQuery.hotkeys-method-areKeysDown\" rel=\"jQuery.hotkeys-method-areKeysDown\" class=\"docClass\">jQuery.hotkeys.areKeysDown</a>('ctrl')) {\n      myTeam.soldiers.forEach(function(soldier) {\n        soldier.selected = false;\n      });\n    }\n  }\n}, 1000); // Set the weight below everything else so we can cancel bubbling\n// Disable the right-click menu\ncanvas.oncontextmenu = function() { return false; };\n</code></pre>\n\n<p>We used a <code>listen()</code> method above provided by the <code>Box</code> class, but <code>Layer</code>s\ndon't have that, so we used <code><a href=\"#!/api/App.Events-static-method-listen\" rel=\"App.Events-static-method-listen\" class=\"docClass\">App.Events.listen</a>()</code> instead. We also disabled the\nright-click menu by canceling the <code>oncontextmenu</code> event.</p>\n\n<p>We still haven't implemented the <code>moveSelectedSoldiersToMouse()</code> method,\nwithout which we're still not doing anything interesting. The actual\nimplementation is not especially important for our purposes; you could make\nthis as sophisticated as you want. Since this is an example, we'll opt for\nclarity over sophistication. At the end of the file:</p>\n\n<pre><code>function moveSelectedSoldiersToMouse() {\n  myTeam.soldiers.forEach(function(soldier) {\n    if (soldier.selected) {\n      soldier.moveTo(<a href=\"#!/api/Mouse.Coords-method-worldX\" rel=\"Mouse.Coords-method-worldX\" class=\"docClass\">Mouse.Coords.worldX</a>(), <a href=\"#!/api/Mouse.Coords-method-worldY\" rel=\"Mouse.Coords-method-worldY\" class=\"docClass\">Mouse.Coords.worldY</a>());\n    }\n  });\n}\n</code></pre>\n\n<p>The key here is the\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/Mouse.Coords\"><code>Mouse.Coords</code></a>\ncalls. The <code>worldX()</code> and <code>worldY()</code> methods return the position of the mouse\ncoordinates relative to the world origin, which is what we want in order to\ninteract with the world. <code><a href=\"#!/api/Mouse.Coords\" rel=\"Mouse.Coords\" class=\"docClass\">Mouse.Coords</a></code> also has <code>x</code> and <code>y</code> properties, which\nhold the mouse coordinates relative to the upper-left corner of the canvas.</p>\n\n<p>Now we've got something interesting going! We can move our soldiers around the\nworld and watch them fight.</p>\n\n<p><img src=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/raw/gh-pages/guides/mouse/screen02.png\" alt=\"Fighting\" /></p>\n\n<p><em><a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/blob/gh-pages/guides/mouse/rts03-click.js\">Review the code for this section</a></em></p>\n\n<h2 id='mouse-section-mouse-dragging'>Mouse Dragging</h2>\n\n<p>Moving around a few soldiers at a time is well and good, but it's a pain to\nselect a lot of them. Let's add rubber-band selection &mdash; the ability to\nselect many soldiers at once by clicking-and-dragging. We'll want to display\nthe region that will be selected as we're dragging.</p>\n\n<p>First, add this code in <code>setup()</code> before <code><a href=\"#!/api/Mouse.Zoom-static-method-enable\" rel=\"Mouse.Zoom-static-method-enable\" class=\"docClass\">Mouse.Zoom.enable</a>()</code> but after\n<code>if (!first) return</code>:</p>\n\n<pre><code>// Set up the drag-to-select rectangle.\nsetupDragOverlay(bkgd, function(x, y, w, h) {\n  // Position a box where the drag rectangle was\n  var selectBox = new Box(x, y, w, h);\n  // See which soldiers are inside the box, and then select the ones that are\n  var toSelect = selectBox.collides(myTeam.soldiers, true);\n  if (toSelect) {\n    for (var i = 0; i &lt; toSelect.length; i++) {\n      toSelect[i].toggleSelected();\n    }\n  }\n});\n</code></pre>\n\n<p><code>setupDragOverlay()</code> will add the appropriate mouse listeners and invoke our\ncallback when the dragging is released and we're ready to actually select\nsoldiers. We'll be passed the coordinates and size of the selection box, and\nwe then check the intersection of that box with selectable soldiers.</p>\n\n<p>Here's the implementation of <code>setupDragOverlay()</code>. Put it at the end of the\nfile:</p>\n\n<pre><code>/**\n * Create an overlay to track mouse-drag selection.\n *\n * @param bkgd The object which should listen for click-and-dragging.\n * @param stopDraggingCallback A function to call when dragging stops.\n * @return The drag-overlay Layer.\n */\nfunction setupDragOverlay(bkgd, stopDraggingCallback) {\n  // Set up a layer to hold the drag-and-drop rectangle.\n  var dragOverlay = new Layer({relative: 'canvas'});\n  dragOverlay.context.fillStyle = 'rgba(255, 240, 40, 0.4)';\n  dragOverlay.context.strokeStyle = 'rgba(255, 240, 40, 1.0)';\n  dragOverlay.context.lineWidth = 2;\n  dragOverlay.positionOverCanvas();\n\n  // Whether we're currently drag-selecting\n  var mousedown = false;\n\n  // Respond to pointer events\n  <a href=\"#!/api/App.Events-static-method-listen\" rel=\"App.Events-static-method-listen\" class=\"docClass\">App.Events.listen</a>(bkgd, 'mousedown.bkgd, touchstart.bkgd', function(e) {\n    // Left click only\n    if (e.type == 'mousedown' &amp;&amp; e.which !== 1) return;\n    // Single-touch only so we don't interfere with gestures\n    if (e.type == 'touchstart' &amp;&amp; (e.touches || e.originalEvent.touches).length &gt; 1) return;\n    // Only listen to the first mousedown in a gesture\n    if (mousedown) return;\n    mousedown = true;\n    // Start drawing the overlay rect\n    dragOverlay.startX = <a href=\"#!/api/Mouse.Coords-property-physicalX\" rel=\"Mouse.Coords-property-physicalX\" class=\"docClass\">Mouse.Coords.physicalX</a>;\n    dragOverlay.startY = <a href=\"#!/api/Mouse.Coords-property-physicalY\" rel=\"Mouse.Coords-property-physicalY\" class=\"docClass\">Mouse.Coords.physicalY</a>;\n  }, 1000); // Set the weight below everything else so we can cancel bubbling\n  $canvas.on('mousemove.dragselect touchmove.dragselect', function(e) {\n    if (mousedown) {\n      // Draw the overlay rect\n      dragOverlay.context.clear();\n      dragOverlay.context.fillRect(\n          dragOverlay.startX, dragOverlay.startY,\n          <a href=\"#!/api/Mouse.Coords-property-physicalX\" rel=\"Mouse.Coords-property-physicalX\" class=\"docClass\">Mouse.Coords.physicalX</a> - dragOverlay.startX,\n          <a href=\"#!/api/Mouse.Coords-property-physicalY\" rel=\"Mouse.Coords-property-physicalY\" class=\"docClass\">Mouse.Coords.physicalY</a> - dragOverlay.startY\n      );\n      dragOverlay.context.strokeRect(\n          dragOverlay.startX, dragOverlay.startY,\n          <a href=\"#!/api/Mouse.Coords-property-physicalX\" rel=\"Mouse.Coords-property-physicalX\" class=\"docClass\">Mouse.Coords.physicalX</a> - dragOverlay.startX,\n          <a href=\"#!/api/Mouse.Coords-property-physicalY\" rel=\"Mouse.Coords-property-physicalY\" class=\"docClass\">Mouse.Coords.physicalY</a> - dragOverlay.startY\n      );\n    }\n  });\n  $canvas.on('mouseup.dragselect mouseleave.dragselect touchend.dragselect', function(e) {\n    if (e.type == 'mouseup' &amp;&amp; e.which !== 1) return; // left click or touch only\n    if (mousedown) {\n      // Stop drawing the overlay rect\n      dragOverlay.context.clear();\n      var x = Math.round(Math.min(dragOverlay.startX, <a href=\"#!/api/Mouse.Coords-property-physicalX\" rel=\"Mouse.Coords-property-physicalX\" class=\"docClass\">Mouse.Coords.physicalX</a>) * world._actualXscale) + world.xOffset,\n          y = Math.round(Math.min(dragOverlay.startY, <a href=\"#!/api/Mouse.Coords-property-physicalY\" rel=\"Mouse.Coords-property-physicalY\" class=\"docClass\">Mouse.Coords.physicalY</a>) * world._actualYscale) + world.yOffset,\n          w = Math.round(Math.abs(<a href=\"#!/api/Mouse.Coords-property-physicalX\" rel=\"Mouse.Coords-property-physicalX\" class=\"docClass\">Mouse.Coords.physicalX</a> - dragOverlay.startX) * world._actualXscale),\n          h = Math.round(Math.abs(<a href=\"#!/api/Mouse.Coords-property-physicalY\" rel=\"Mouse.Coords-property-physicalY\" class=\"docClass\">Mouse.Coords.physicalY</a> - dragOverlay.startY) * world._actualYscale);\n      if (w &amp;&amp; h) {\n        // Do something with the selection\n        stopDraggingCallback(x, y, w, h);\n      }\n    }\n    mousedown = false;\n  });\n\n  return dragOverlay;\n}\n</code></pre>\n\n<p>Other than the fact that this is a lot of code, there are really only two\nthings to note here. First, we are displaying the selection box in a <code>Layer</code>\nthat is positioned over the canvas; we could also have just created a <code>Box</code>\ninside the world, set its coordinates to <code><a href=\"#!/api/Mouse.Coords-method-worldX\" rel=\"Mouse.Coords-method-worldX\" class=\"docClass\">Mouse.Coords.worldX</a>()</code> /\n<code><a href=\"#!/api/Mouse.Coords-method-worldY\" rel=\"Mouse.Coords-method-worldY\" class=\"docClass\">Mouse.Coords.worldY</a>()</code>, and changed its <code>width</code> and <code>height</code> as we dragged.\nSecond, there are some complicated calculations happening at the end to\ndetermine the parameters to pass to the <code>stopDraggingCallback</code>. This is a\nconversion from on-screen pixels to in-world coordinates, taking into account\nzooming. This is usually not necessary, and there are usually alternatives to\ndoing this, but here's how you do it if you need to.</p>\n\n<p>Other than that, there's nothing new here: we're mixing <code><a href=\"#!/api/App.Events-static-method-listen\" rel=\"App.Events-static-method-listen\" class=\"docClass\">App.Events.listen</a></code> and\n<code>$canvas.on</code> for no good reason other than illustration, really, and we're\nstill just using <code><a href=\"#!/api/Mouse.Coords\" rel=\"Mouse.Coords\" class=\"docClass\">Mouse.Coords</a></code> to get the mouse's location.</p>\n\n<p><img src=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/raw/gh-pages/guides/mouse/screen03.png\" alt=\"Dragging\" /></p>\n\n<p>While we're on the topic of dragging, you should know that drag-&amp;-drop\nfunctionality is also supported. We don't have a good use for it in this\ngame so far, but you enable it on specific <code>Actor</code>s by calling\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/api/Actor-method-setDraggable\">Actor#setDraggable</a>.\nFor an amusing example, try executing this code in your browser's JavaScript\nconsole:</p>\n\n<pre><code>soldiers.forEach(function(soldier) {\n  soldier.setDraggable(true);\n});\n</code></pre>\n\n<p>This will make all soldiers that have been spawned so far draggable (try it;\nclick on one and drag it around.) You'll notice that it kind of interferes with\nour drag-to-select functionality.</p>\n\n<p><em><a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/blob/gh-pages/guides/mouse/rts04-drag.js\">Review the code for this section</a></em></p>\n\n<h2 id='mouse-section-exercises-for-the-reader'>Exercises for the Reader</h2>\n\n<p>We've now encountered all the mouse interaction tools this project provides,\nand in combination with the basics walkthrough, all the rapid prototyping tools\navailable (though not every feature of each tool &mdash; for that, see the\nfull documentation for each class). There are still some features that are\nmissing from the game we've built compared to full RTS games. These can be\nwritten with the tools we've already encountered, so they're not covered here\nfor brevity. It's a good exercise to implement these features yourself. If you\nget stuck or want to see the end product, you can\n<a href=\"http://icecreamyou.github.com/HTML5-Canvas-Game-Boilerplate/examples/cnc.html\">play with</a> or\n<a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/blob/gh-pages/examples/cnc.js\">read the code</a>\nof a more complete example.</p>\n\n<h2 id='mouse-section-recap'>Recap</h2>\n\n<p>We've implemented quite a lot of powerful features with little code. Your game\nis already fun to play with, and with some polish, it will be ready to show off\nto your friends!</p>\n\n<p>These tools are quite flexible and are useful in many different scenarios\nbeyond an RTS game. You can\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/\">read the complete API reference</a> or\n<a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate/wiki/What%27s-Included-&amp;-API-Overview\">view a comprehensive feature list</a>\nto get more familiar with them. Also feel free to dig through the code; it's\nwell-documented. If you'd like a recap of the basics, check out the\n<a href=\"http://icecreamyou.github.io/HTML5-Canvas-Game-Boilerplate/docs/#!/guide/walkthrough\">first tutorial</a>.</p>\n\n<p>Congratulations! Go\n<a href=\"https://github.com/IceCreamYou/HTML5-Canvas-Game-Boilerplate\">get the code</a> if\nyou haven't already, and build something awesome!</p>\n","title":"Mouse Interaction"});