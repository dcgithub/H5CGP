<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * Handles mouse motion/tracking, scrolling, and dragging.
 *
 * @ignore
 */

<span id='App-static-property-isSomethingBeingDragged'>/**
</span> * @property
 *   Whether an {@link Actor} is being dragged.
 *
 * Drop targets can change how they look when a draggable object is hovered
 * over them by testing `this.isHovered() &amp;&amp; App.isSomethingBeingDragged` in
 * their {@link Box#draw draw()} methods.
 *
 * @member App
 * @static
 */
App.isSomethingBeingDragged = false;

<span id='Mouse'>/**
</span> * Handles mouse motion and scrolling.
 * @static
 * @ignore
 */
var Mouse = {
<span id='Mouse-Coords'>    /**
</span>     * @class Mouse.Coords
     *   Handles mouse coordinates.
     * @static
     */
    Coords: {
<span id='Mouse-Coords-property-x'>      /**
</span>       * The mouse x-coordinate relative to the upper-left corner of the canvas.
       *
       * This value is actually relative to `canvas.width` and `canvas.height`,
       * which is an important distinction when the canvas is scaled using
       * {@link World#scaleResolution}. It represents the horizontal location
       * of the mouse on the rendered buffer before it is scaled by CSS. When
       * you want the x-coordinate of the mouse relative to the canvas, this is
       * usually what you want to use.
       */
      x: -9999,
<span id='Mouse-Coords-property-y'>      /**
</span>       * The mouse y-coordinate relative to the upper-left corner of the canvas.
       *
       * This value is actually relative to `canvas.width` and `canvas.height`,
       * which is an important distinction when the canvas is scaled using
       * {@link World#scaleResolution}. It represents the vertical location of
       * the mouse on the rendered buffer before it is scaled by CSS. When you
       * want the y-coordinate of the mouse relative to the canvas, this is
       * usually what you want to use.
       */
      y: -9999,
<span id='Mouse-Coords-property-physicalX'>      /**
</span>       * The mouse x-coordinate over the canvas DOM element.
       *
       * This value is actually relative to `$canvas.css(&#39;width&#39;)` and
       * `$canvas.css(&#39;height&#39;)`, or the display size of the canvas. This can
       * be different than the size at which the canvas is rendered if the
       * canvas is scaled with {@link World#scaleResolution}. You may want to
       * use this if you are positioning DOM elements over the canvas.
       */
      physicalX: -9999,
<span id='Mouse-Coords-property-physicalY'>      /**
</span>       * The mouse y-coordinate over the canvas DOM element.
       *
       * This value is actually relative to `$canvas.css(&#39;width&#39;)` and
       * `$canvas.css(&#39;height&#39;)`, or the display size of the canvas. This can
       * be different than the size at which the canvas is rendered if the
       * canvas is scaled with {@link World#scaleResolution}. You may want to
       * use this if you are positioning DOM elements over the canvas.
       */
      physicalY: -9999,
<span id='Mouse-Coords-method-worldX'>      /**
</span>       * The mouse x-coordinate relative to the world.
       *
       * Use this if you want the pointer to interact with the world.
       */
      worldX: function() {
        return this.x &gt;= 0 ? this.x + world.xOffset : -9999;
      },
<span id='Mouse-Coords-method-worldY'>      /**
</span>       * The mouse y-coordinate relative to the world.
       *
       * Use this if you want the pointer to interact with the world.
       */
      worldY: function() {
        return this.y &gt;= 0 ? this.y + world.yOffset : -9999;
      },
    },
};

// Track mouse events
jQuery(document).ready(function() {
  // Callback for mouse/touch-move event to track cursor location
  var trackmove = function(e) {
    try {
      // Get the cursor location
      var x = e.pageX || e.originalEvent.touches[0].pageX;
      var y = e.pageY || e.originalEvent.touches[0].pageY;
      // Prevent window scrolling on iPhone and display freeze on Android
      if (e.type == &#39;touchmove&#39;) {
        e.preventDefault();
      }
      // The position we want is relative to the canvas
      Mouse.Coords.physicalX = x - $canvas.offset().left;
      Mouse.Coords.physicalY = y - $canvas.offset().top;
      // Adjust for scaled resolution
      Mouse.Coords.x = Math.round(Mouse.Coords.physicalX * world._actualXscale);
      Mouse.Coords.y = Math.round(Mouse.Coords.physicalY * world._actualYscale);
    }
    catch(ex) {
      // Don&#39;t report anything. Probably the reason we had an error is because
      // the mouse moved off the document so neither the pageX/Y nor the
      // touches properties have meaningful values.
    }
  };

  // Track cursor for touches
  $canvas.on(&#39;touchmove.coords&#39;, trackmove);
  // For mice, only track the cursor when it&#39;s over the canvas
  $canvas.hover(function() {
    jQuery(this).on(&#39;mousemove.coords&#39;, trackmove);
  }, function() {
    jQuery(this).off(&#39;mousemove.coords&#39;);
    Mouse.Coords.physicalX = -9999;
    Mouse.Coords.physicalY = -9999;
    Mouse.Coords.x = -9999;
    Mouse.Coords.y = -9999;
  });

  // Track and delegate click events
  $canvas.on(&#39;mousedown mouseup click touchstart touchend&#39;, function(e) {
    if (e.type == &#39;touchstart&#39;) {
      trackmove(e);
    }
    if (isAnimating() &amp;&amp; typeof App.Events !== &#39;undefined&#39;) {
      App.Events.trigger(e.type, e);
    }
  });

  // Track and delegate dragend events
  $canvas.on(&#39;mouseup.drag touchend.drag&#39;, function(e) {
    if (typeof App.Events !== &#39;undefined&#39;) {
      App.Events.trigger(&#39;canvasdragstop&#39;, e);
    }
    App.isSomethingBeingDragged = false;
<span id='global-event-canvasdragstop'>    /**
</span>     * @event canvasdragstop
     *   Fires on the document when the player stops dragging an object,
     *   i.e. when the player releases the mouse or stops touching the canvas.
     * @member global
     */
    jQuery(document).trigger(&#39;canvasdragstop&#39;);
  });

  // Track and delegate drop events
  jQuery(document).on(&#39;canvasdrop&#39;, function(e, target) {
    if (typeof App.Events !== &#39;undefined&#39;) {
      App.Events.trigger(&#39;canvasdrop&#39;, e, target);
    }
  });
});

<span id='App-static-method-isHovered'>/**
</span> * Determine whether the mouse is hovering over an object.
 *
 * The object in question must have these properties: `x`, `y`, `width`,
 * `height`. (All {@link Box}es have these properties.)
 *
 * @param {Box} obj
 *   The object to check.
 *
 * @return {Boolean}
 *   Whether the mouse is hovering over the object.
 *
 * @member App
 * @static
 */
App.isHovered = function(obj) {
  return Mouse.Coords.worldX() &gt; obj.x &amp;&amp; Mouse.Coords.worldX() &lt; obj.x + obj.width &amp;&amp;
      Mouse.Coords.worldY() &gt; obj.y &amp;&amp; Mouse.Coords.worldY() &lt; obj.y + obj.height;
};

<span id='Mouse-Scroll'>/**
</span> * @class Mouse.Scroll
 *   Encapsulates mouse position scrolling.
 *
 * Note that mouse scrolling will be temporarily paused while the mouse is down
 * to avoid scrolling while the user is trying to select something.
 *
 * @static
 */
Mouse.Scroll = (function() {
  var THRESHOLD = 0.2, MOVEAMOUNT = 350;
  // Whether we&#39;re allowed to mouse scroll
  var enabled = false;
  // If enabled is true, then whether the mouse is over the canvas
  var hovered = false;
  // Whether the mouse is pressed down over the canvas
  var mousedown = false;
  // Whether we&#39;re currently scrolling
  var translating = false;
  // How far we scrolled last time
  var scrolled = {x: 0, y: 0};
  // Available easing functions
  var easings = {
      THRESHOLD: function() { return 1; },
      LINEAR: function(val) { return 1-val; },
      SMOOTH: function(val) { return 0.5 - Math.cos( (1-val)*Math.PI ) / 2; },
      EXPONENTIAL: function(val) { return Math.sqrt(1-val); },
  };
  // The currently active easing function
  var easing = easings.SMOOTH;

  function translate() {
    var ma, gradient, initialTranslationState = translating;

    // Left
    if (Mouse.Coords.x &lt; canvas.width * THRESHOLD) {
      gradient = easing(Mouse.Coords.x / (canvas.width * THRESHOLD));
      ma = Math.round(gradient*Math.min(world.xOffset, MOVEAMOUNT * App.physicsDelta));
      world.xOffset -= ma;
      scrolled.x -= ma;
      context.translate(ma, 0);
    }
    // Right
    else if (Mouse.Coords.x &gt; canvas.width * (1-THRESHOLD)) {
      gradient = easing((canvas.width - Mouse.Coords.x) / (canvas.width * THRESHOLD));
      ma = Math.round(gradient*Math.min(world.width - canvas.width - world.xOffset, MOVEAMOUNT * App.physicsDelta));
      world.xOffset += ma;
      scrolled.x += ma;
      context.translate(-ma, 0);
    }

    // Up
    if (Mouse.Coords.y &lt; canvas.height * THRESHOLD) {
      gradient = easing(Mouse.Coords.y / (canvas.height * THRESHOLD));
      ma = Math.round(gradient*Math.min(world.yOffset, MOVEAMOUNT * App.physicsDelta));
      world.yOffset -= ma;
      scrolled.y -= ma;
      context.translate(0, ma);
    }
    // Down
    else if (Mouse.Coords.y &gt; canvas.height * (1-THRESHOLD)) {
      gradient = easing((canvas.height - Mouse.Coords.y) / (canvas.height * THRESHOLD));
      ma = Math.round(gradient*Math.min(world.height - canvas.height - world.yOffset, MOVEAMOUNT * App.physicsDelta));
      world.yOffset += ma;
      scrolled.y += ma;
      context.translate(0, -ma);
    }

    // We&#39;re not translating if we&#39;re not moving.
    translating = scrolled.x !== 0 &amp;&amp; scrolled.y !== 0;

    // We weren&#39;t scrolling. Now we are. Fire the relevant event.
    if (!initialTranslationState &amp;&amp; translating) {
<span id='Mouse-Scroll-event-mousescrollon'>      /**
</span>       * @event mousescrollon
       *   Fires on the document when the viewport starts scrolling. Binding
       *   to this event may be useful if you want to pause animation or
       *   display something while the viewport is moving.
       */
      jQuery(document).trigger(&#39;mousescrollon&#39;);
    }
    // We were scrolling. Now we&#39;re not. Fire the relevant event.
    else if (initialTranslationState &amp;&amp; !translating) {
<span id='Mouse-Scroll-event-mousescrolloff'>      /**
</span>       * @event mousescrolloff
       *   Fires on the document when the viewport stops scrolling. Binding
       *   to this event may be useful if you want to pause animation or
       *   display something while the viewport is moving.
       */
      jQuery(document).trigger(&#39;mousescrolloff&#39;);
    }
    return scrolled;
  }
  return {
<span id='Mouse-Scroll-static-method-enable'>    /**
</span>     * Enable mouse position scrolling.
     * @static
     */
    enable: function() {
      if (enabled) {
        return;
      }
      enabled = true;
      $canvas.one(&#39;mousemove.translate&#39;, function() {
        // Enable translating if we&#39;re over the canvas
        if (Mouse.Coords.x &gt;= 0 &amp;&amp; Mouse.Coords.y &gt;= 0) {
          hovered = true;
          translate();
        }
      });
      $canvas.on(&#39;mouseenter.translate touchstart.translate&#39;, function() {
        hovered = true;
        translate();
      });
      $canvas.on(&#39;mouseleave.translate touchleave.translate&#39;, function() {
        hovered = false;
        if (translating) {
          translating = false;
          jQuery(document).trigger(&#39;mousescrolloff&#39;);
        }
      });
      $canvas.on(&#39;mousedown.translate touchstart.translate&#39;, function() {
        mousedown = true;
      });
      $canvas.on(&#39;mouseup.translate touchend.translate&#39;, function() {
        mousedown = false;
      });
    },
<span id='Mouse-Scroll-static-method-disable'>    /**
</span>     * Disable mouse position scrolling.
     * @static
     */
    disable: function() {
      $canvas.off(&#39;.translate&#39;);
      hovered = false;
      enabled = false;
      translating = false;
    },
<span id='Mouse-Scroll-static-method-isEnabled'>    /**
</span>     * Test whether mouse position scrolling is enabled.
     * @static
     */
    isEnabled: function() {
      return enabled;
    },
<span id='Mouse-Scroll-static-method-isScrolling'>    /**
</span>     * Test whether the viewport is currently mouse-scrolling.
     *
     * There is one weird edge case: this will return true if the user is in
     * the middle of a click-and-drag action that was started while the
     * viewport was scrolling.
     *
     * @static
     */
    isScrolling: function() {
      return translating;
    },
    // Called in the core animation loop.
    _update: function() {
      // Don&#39;t scroll while dragging.
      if (hovered &amp;&amp; !mousedown) {
        return translate();
      }
    },
<span id='Mouse-Scroll-static-property-easings'>    /**
</span>     * Available easing modes for scroll movement speed.
     *
     * Modes include:
     *
     * - THRESHOLD: Scroll at max speed when the mouse is past the threshold
     * - LINEAR: Increase scroll speed linearly as the mouse approaches an edge
     * - SMOOTH: S-curve &quot;swing&quot; easing (default)
     * - EXPONENTIAL: Increase scroll speed inverse-exponentially as the mouse
     *   approaches an edge (increase quickly at first, then plateau)
     *
     * @static
     */
    easings: easings,
<span id='Mouse-Scroll-static-method-setEasingFunction'>    /**
</span>     * Set the easing function used to determine scroll speed.
     *
     * The `easings` property contains the possible easing functions, or you
     * can define your own.
     *
     * @static
     */
    setEasingFunction: function(e) {
      easing = e;
    },
<span id='Mouse-Scroll-static-method-getEasingFunction'>    /**
</span>     * Get the easing function used to determine scroll speed.
     *
     * The `easings` property contains the possible easing functions.
     *
     * @static
     */
    getEasingFunction: function() {
      return easing;
    },
<span id='Mouse-Scroll-static-method-setThreshold'>    /**
</span>     * Set how close to the edge of the canvas the mouse triggers scrolling.
     *
     * The threshold is a fractional percentage [0.0-0.5) of the width of the
     * canvas. If the mouse is within this percent of the edge of the canvas,
     * the viewport attempts to scroll. The default threshold is 0.2 (20%).
     *
     * See also Mouse.Scroll.getThreshold().
     *
     * @static
     */
    setThreshold: function(t) {
      THRESHOLD = t;
    },
<span id='Mouse-Scroll-static-method-getThreshold'>    /**
</span>     * Get how close to the edge of the canvas the mouse triggers scrolling.
     *
     * See also Mouse.Scroll.getThreshold().
     *
     * @return {Number}
     *   The mouse-scrolling threshold. The threshold is a fractional
     *   percentage [0.0-0.5) of the width of the canvas. If the mouse is
     *   within this percent of the edge of the canvas, the viewport attempts
     *   to scroll. The default threshold is 0.2 (20%).
     *
     * @static
     */
    getThreshold: function() {
      return THRESHOLD;
    },
<span id='Mouse-Scroll-static-method-setScrollDistance'>    /**
</span>     * Set how fast the mouse will cause the viewport to scroll.
     *
     * The actual scrolling speed also depends on the easing function. The
     * scroll speed set here is actually the maximum scroll speed.
     *
     * @param {Number} a
     *   The maximum distance in pixels that the viewport will move each second
     *   while scrolling (the movement can be less when the viewport is very
     *   close to an edge of the world). Defaults to 350.
     *
     * @static
     */
    setScrollDistance: function(a) {
      MOVEAMOUNT = a;
    },
<span id='Mouse-Scroll-static-method-getScrollDistance'>    /**
</span>     * Get how fast the mouse will cause the viewport to scroll.
     *
     * The actual scrolling speed also depends on the easing function. The
     * scroll speed retrieved here is actually the maximum scroll speed.
     *
     * @return {Number}
     *   The maximum distance in pixels that the viewport will move each second
     *   while scrolling (the movement can be less when the viewport is very
     *   close to an edge of the world). Defaults to 350.
     *
     * @static
     */
    getScrollDistance: function() {
      return MOVEAMOUNT;
    },
  };
})();
</pre>
</body>
</html>
